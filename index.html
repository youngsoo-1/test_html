!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlopperTest InDev</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 dark:bg-[#2f2f2f] h-screen flex flex-col items-center justify-center overflow-hidden relative transition-colors duration-300">
    <div class="absolute top-4 right-4">
        <button onclick="toggleSettings()" class="bg-gray-200 dark:bg-[#343332] p-2 rounded-lg hover:bg-gray-300 dark:hover:bg-[#2f2f2f] transition-colors"
                aria-label="Settings">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-gray-600 dark:text-gray-300" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
            </svg>
        </button>
        <div id="settingsMenu" class="absolute right-0 mt-2 w-48 bg-white dark:bg-[#343332] rounded-lg shadow-lg p-4 transform scale-0 opacity-0 transition-all duration-200 origin-top-right">
            <div class="flex items-center justify-between">
                <span class="text-gray-700 dark:text-gray-300">Dark Mode</span>
                <button onclick="toggleDarkMode()" class="relative inline-flex items-center h-6 rounded-full w-11 transition-colors focus:outline-none" id="darkModeToggle">
                    <span class="absolute h-5 w-5 rounded-full transition-transform transform bg-white shadow-md" id="darkModeToggleKnob"></span>
                </button>
            </div>
        </div>
    </div>
    <div class="bg-white dark:bg-[#343332] p-8 rounded-lg shadow-lg text-center">
        <div class="text-2xl mb-5 text-gray-800">are you a fish?</div>
        <div class="flex gap-4 justify-center">
            <button onclick="showResult(true)" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded transition-colors">
                yes
            </button>
            <button onclick="showResult(false)" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded transition-colors">
                no
            </button>
        </div>
        <div class="mt-4">
            <button onclick="resetAll()" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded transition-colors">
                reset
            </button>
        </div>
        <div id="result" class="mt-5 font-bold text-xl opacity-0 transition-opacity duration-500"></div>
    </div>

    <audio id="lieAudio" src="assets/audio.mp3"></audio>
    <audio id="audio2" src="assets/audio2.mp3"></audio>
    <audio id="audio3" src="assets/audio3.mp3"></audio>
    <script>
        let fishCount = 0;
        const maxFish = 10;

        function toggleSettings() {
            const menu = document.getElementById('settingsMenu');
            const isOpen = menu.classList.contains('scale-100');
            
            if (isOpen) {
                menu.classList.remove('scale-100', 'opacity-100');
                menu.classList.add('scale-0', 'opacity-0');
            } else {
                menu.classList.remove('scale-0', 'opacity-0');
                menu.classList.add('scale-100', 'opacity-100');
            }
        }

        function toggleDarkMode() {
            const html = document.documentElement;
            const isDark = html.classList.toggle('dark');
            const toggle = document.getElementById('darkModeToggle');
            const knob = document.getElementById('darkModeToggleKnob');

            if (isDark) {
                toggle.classList.add('bg-blue-600');
                knob.classList.add('translate-x-5');
            } else {
                toggle.classList.remove('bg-blue-600');
                knob.classList.remove('translate-x-5');
            }
        }

        // Add click outside handler for settings menu
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('settingsMenu');
            const settingsButton = document.querySelector('button[onclick="toggleSettings()"]');
            if (!menu.contains(e.target) && !settingsButton.contains(e.target) && menu.classList.contains('scale-100')) {
                toggleSettings();
            }
        });

        class BouncingLie {
            constructor() {
                this.element = document.createElement('img');
                this.element.src = 'assets/flopper.png';
                this.element.className = 'absolute w-24 h-24 pointer-events-none';
                this.element.alt = 'Bouncing fish';
                this.element.addEventListener('error', () => {
                    this.element.src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg"/>';
                });
                const container = document.querySelector('.bg-white');
                const containerRect = container.getBoundingClientRect();
                const imageWidth = 96;
                const imageHeight = 96;
                
                // Keep generating random positions until we find one outside the central platform
                do {
                    this.x = Math.random() * (window.innerWidth - imageWidth);
                    this.y = Math.random() * (window.innerHeight - imageHeight);
                } while (
                    this.x + imageWidth > containerRect.left && 
                    this.x < containerRect.right && 
                    this.y + imageHeight > containerRect.top && 
                    this.y < containerRect.bottom
                );
                const getRandomSpeed = () => (Math.random() * 2 - 1) * 15;
                this.dx = getRandomSpeed();
                this.dy = getRandomSpeed();
                if (Math.abs(this.dx) < 10) this.dx *= 1.5;
                if (Math.abs(this.dy) < 10) this.dy *= 1.5;
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
                this.element.bouncingLieInstance = this;
                document.body.appendChild(this.element);
                this.animate();
            }

            animate() {
                let isRunning = true;
                const animate = () => {
                    if (!isRunning) {
                        this.element.remove();
                        return;
                    }
                    const container = document.querySelector('.bg-white');
                    const containerRect = container.getBoundingClientRect();
                    let nextX = this.x + this.dx;
                    let nextY = this.y + this.dy;
                    const imageWidth = 96;
                    const imageHeight = 96;
                    if (nextX + imageWidth > containerRect.left && nextX < containerRect.right &&
                        nextY + imageHeight > containerRect.top && nextY < containerRect.bottom) {
                        if (nextX + imageWidth > containerRect.left && nextX < containerRect.right) {
                            this.dx = -this.dx;
                        }
                        if (nextY + imageHeight > containerRect.top && nextY < containerRect.bottom) {
                            this.dy = -this.dy;
                        }
                    }
                    this.x += this.dx;
                    this.y += this.dy;
                    if (this.x <= 0 || this.x >= window.innerWidth - imageWidth) {
                        this.dx = -this.dx;
                    }
                    if (this.y <= 0 || this.y >= window.innerHeight - imageHeight) {
                        this.dy = -this.dy;
                    }
                    this.element.style.left = `${this.x}px`;
                    this.element.style.top = `${this.y}px`;
                    requestAnimationFrame(animate);
                };
                animate();
                this.cleanup = () => {
                    isRunning = false;
                };
            }
        }

        function createFlyingLie() {
            if (fishCount < maxFish) {
                new BouncingLie();
                fishCount++;
            }
        }

        function showResult(isYes) {
            // Add error handling for audio
            const playAudioSafely = (audio) => {
                audio.play().catch(error => {
                    console.warn('Audio playback failed:', error);
                });
            };

            if (isYes) {
                const audio2 = document.getElementById('audio2');
                const audio3 = document.getElementById('audio3');
                
                const onEnded = () => {
                    playAudioSafely(audio3);
                    audio2.removeEventListener('ended', onEnded);
                };
                
                audio2.addEventListener('ended', onEnded);
                playAudioSafely(audio2);
            }
            const resultElement = document.getElementById('result');
            resultElement.textContent = isYes ? 'fishy flopper' : 'LIE DETECTED';
            resultElement.classList.remove('opacity-0');
            void resultElement.offsetWidth;
            resultElement.classList.add('opacity-100');
            const yesButton = document.querySelector('button[onclick="showResult(true)"]');
            const noButton = document.querySelector('button[onclick="showResult(false)"]');
            if (isYes) {
                noButton.classList.add('hidden');
            } else {
                yesButton.classList.add('hidden');
            }
            if (isYes) {
                const audio2 = document.getElementById('audio2');
                const audio3 = document.getElementById('audio3');
                audio2.play();
                audio2.addEventListener('ended', () => {
                    audio3.play();
                });
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => createFlyingLie(), i * 200);
                }
            } else {
                const audio = document.getElementById('lieAudio');
                let playCount = 0;
                const playAudioRepeatedly = () => {
                    if (playCount < 5) {
                        audio.currentTime = 0;
                        audio.play();
                        playCount++;
                        setTimeout(playAudioRepeatedly, 1000);
                    }
                };
                playAudioRepeatedly();
            }
        }

        function resetAll() {
            fishCount = 0;
            const resultElement = document.getElementById('result');
            resultElement.textContent = '';
            resultElement.classList.remove('opacity-100');
            resultElement.classList.add('opacity-0');
            const yesButton = document.querySelector('button[onclick="showResult(true)"]');
            const noButton = document.querySelector('button[onclick="showResult(false)"]');
            yesButton.classList.remove('hidden');
            noButton.classList.remove('hidden');
            const lieAudio = document.getElementById('lieAudio');
            const audio2 = document.getElementById('audio2');
            const audio3 = document.getElementById('audio3');
            [lieAudio, audio2, audio3].forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });
            document.querySelectorAll('img').forEach(element => {
                if (element.src.includes('flopper.png')) {
                    const bouncingLie = element.bouncingLieInstance;
                    if (bouncingLie && bouncingLie.cleanup) {
                        bouncingLie.cleanup();
                    }
                    element.remove();
                }
            });
            const highestTimeoutId = setTimeout(() => {});
            for (let i = 0; i < highestTimeoutId; i++) {
                clearTimeout(i);
            }
        }
    </script>
</body>
</html>
