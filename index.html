<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlopperTest v1.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 h-screen flex flex-col items-center justify-center overflow-hidden relative">
    <div class="bg-white p-8 rounded-lg shadow-lg text-center">
        <div class="text-2xl mb-5 text-gray-800">are you a fish?</div>
        <div class="flex gap-4 justify-center">
            <button onclick="showResult(true)" class="bg-green-500 hover:bg-green-600 text-white px-6 py-2 rounded transition-colors">
                yes
            </button>
            <button onclick="showResult(false)" class="bg-red-500 hover:bg-red-600 text-white px-6 py-2 rounded transition-colors">
                no
            </button>
        </div>
        <div class="mt-4">
            <button onclick="resetAll()" class="bg-gray-500 hover:bg-gray-600 text-white px-6 py-2 rounded transition-colors">
                reset
            </button>
        </div>
        <div id="result" class="mt-5 font-bold text-xl opacity-0 transition-opacity duration-500"></div>
    </div>

    <audio id="lieAudio" src="assets/audio.mp3"></audio>
    <audio id="audio2" src="assets/audio2.mp3"></audio>
    <audio id="audio3" src="assets/audio3.mp3"></audio>
    <script>
        class BouncingLie {
            constructor() {
                this.element = document.createElement('img');
                this.element.src = 'assets/flopper.png';
                this.element.className = 'absolute w-24 h-24 pointer-events-none';
                this.x = Math.random() * (window.innerWidth - 200);
                this.y = Math.random() * (window.innerHeight - 200);
                // Ensure minimum speed of 15 in both directions
                const getRandomSpeed = () => (Math.random() * 2 - 1) * 15;
                this.dx = getRandomSpeed();
                this.dy = getRandomSpeed();
                
                // Ensure minimum absolute speed
                if (Math.abs(this.dx) < 10) this.dx *= 1.5;
                if (Math.abs(this.dy) < 10) this.dy *= 1.5;
                this.element.style.left = `${this.x}px`;
                this.element.style.top = `${this.y}px`;
                this.element.bouncingLieInstance = this;
                document.body.appendChild(this.element);
                this.animate();
            }

            animate() {
                let isRunning = true;
                const animate = () => {
                    if (!isRunning) {
                        this.element.remove();
                        return;
                    }
                    const container = document.querySelector('.bg-white');
                    const containerRect = container.getBoundingClientRect();

                    // Calculate next position
                    let nextX = this.x + this.dx;
                    let nextY = this.y + this.dy;

                    // Check collision with container
                    const imageWidth = 96; // Width of flopper image (w-24 = 96px)
                    const imageHeight = 96; // Height of flopper image (h-24 = 96px)

                    // Collision with container boundaries
                    if (nextX + imageWidth > containerRect.left && nextX < containerRect.right &&
                        nextY + imageHeight > containerRect.top && nextY < containerRect.bottom) {
                        // Determine which side was hit and reverse appropriate velocity
                        if (nextX + imageWidth > containerRect.left && nextX < containerRect.right) {
                            this.dx = -this.dx;
                        }
                        if (nextY + imageHeight > containerRect.top && nextY < containerRect.bottom) {
                            this.dy = -this.dy;
                        }
                    }

                    // Update position
                    this.x += this.dx;
                    this.y += this.dy;

                    // Screen boundary collision
                    if (this.x <= 0 || this.x >= window.innerWidth - imageWidth) {
                        this.dx = -this.dx;
                    }
                    if (this.y <= 0 || this.y >= window.innerHeight - imageHeight) {
                        this.dy = -this.dy;
                    }

                    this.element.style.left = `${this.x}px`;
                    this.element.style.top = `${this.y}px`;
                    requestAnimationFrame(animate);
                };
                animate();

                // Add cleanup method
                this.cleanup = () => {
                    isRunning = false;
                };
            }
        }

        function createFlyingLie() {
            new BouncingLie();
        }

        function showResult(isYes) {
            const resultElement = document.getElementById('result');
            resultElement.textContent = isYes ? 'fishy flopper' : 'LIE DETECTED';
            resultElement.classList.remove('opacity-0');
            void resultElement.offsetWidth;
            resultElement.classList.add('opacity-100');

            // Hide the unselected button
            const yesButton = document.querySelector('button[onclick="showResult(true)"]');
            const noButton = document.querySelector('button[onclick="showResult(false)"]');
            if (isYes) {
                noButton.classList.add('hidden');
            } else {
                yesButton.classList.add('hidden');
            }

            if (isYes) {
                const audio2 = document.getElementById('audio2');
                const audio3 = document.getElementById('audio3');
                audio2.play();
                audio2.addEventListener('ended', () => {
                    audio3.play();
                });
            } else {
                const audio = document.getElementById('lieAudio');
                let playCount = 0;
                const playAudioRepeatedly = () => {
                    if (playCount < 5) {
                        audio.currentTime = 0;
                        audio.play();
                        playCount++;
                        setTimeout(playAudioRepeatedly, 1000);
                    }
                };
                playAudioRepeatedly();
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => createFlyingLie(), i * 200);
                }
            }
        }

        function resetAll() {
            // Reset result text and ensure it's hidden
            const resultElement = document.getElementById('result');
            resultElement.textContent = '';
            resultElement.classList.remove('opacity-100');
            resultElement.classList.add('opacity-0');

            // Show both buttons
            const yesButton = document.querySelector('button[onclick="showResult(true)"]');
            const noButton = document.querySelector('button[onclick="showResult(false)"]');
            yesButton.classList.remove('hidden');
            noButton.classList.remove('hidden');

            // Stop and reset all audio elements
            const lieAudio = document.getElementById('lieAudio');
            const audio2 = document.getElementById('audio2');
            const audio3 = document.getElementById('audio3');
            [lieAudio, audio2, audio3].forEach(audio => {
                audio.pause();
                audio.currentTime = 0;
            });

            // Remove all flying LIE elements and their animations
            document.querySelectorAll('img').forEach(element => {
                if (element.src.includes('flopper.png')) {
                    const bouncingLie = element.bouncingLieInstance;
                    if (bouncingLie && bouncingLie.cleanup) {
                        bouncingLie.cleanup();
                    }
                    element.remove();
                }
            });

            // Clear any ongoing timeouts for audio or animations
            const highestTimeoutId = setTimeout(() => {});
            for (let i = 0; i < highestTimeoutId; i++) {
                clearTimeout(i);
            }
        }
    </script>
</body>
</html>
